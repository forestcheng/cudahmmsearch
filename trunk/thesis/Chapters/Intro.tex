% Chapter Template

\chapter{Introduction} % Main chapter title

% \label{Intro} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 1. \emph{Introduction}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Problem Statement}

What problem is being solved with the software HMMER3?

Why is the problem important?

Why is an optimized implementation needed?

What is a protein sequence profile HMM, etc

What are the common use cases



In Bioinformatics, HMMER \citep{HMMER} is a free and commonly used software package for sequence analysis written by Sean Eddy. 
HMMER is used to search sequence databases identify homologous protein, which means to identify regions of similarity that may be a consequence of functional, structural, or evolutionary relationships between the protein sequences.

HMMER applies the profile HMM(Hidden Markov Model), which is a promising approach to improve the sensitivity of database-searching. The profile HMM is statistical models of multiple sequence alignment, or even of single sequence. The main strength of a profile HMM is that it is probabilistic finite state machine. This means that it assesses the probability of match, insert and delete at a given position of an alignment.

Unlike conventional pairwise comparisons, a consensus profile HMM model can in principle utilize additional statistical information, such as the position and identity of residues that are more or less conserved throughout the family, as well as variable insertion and deletion probabilities. By developing a statistical model that is based on known sequences in a protein family, a profile HMM can be used to model the protein sequence family.

Based on the strength of its underlying profile HMMs, HMMER aims to be significantly more accurate and more able to detect remote homologs, compared to BLAST, FASTA, and other sequence alignment and database search tools based on older scoring methodology.

In HMMER, the application \emph{hmmbuild} is used to build a profile HMM using a multiple sequence alignment, or single sequence as input. 

The widely used application \emph{hmmsearch} in HMMER, is used to search a profile HMM against a sequence database, finding whether a sequence is member of the family described by a profile HMM. \emph{hmmsearch} output ranked list of the sequences with the most significant matches to the profile. Another similar application in HMMER, \emph{hmmscan} is the query of a single protein sequence of interest against a database of profile HMMs.

To compare a profile HMM with a protein sequence, HMMER uses Viterbi algorithm described in subsection \ref{ViterbiSub}, which evaluates the path that has the maximum probability of the profile HMM generating the sequence. Viterbi is a dynamic programming algorithm.
The fundamental task of the Viterbi algorithm for biological sequence alignment is to calculate three DP(Dynamic Programming) matrices: $M[{ }]$ for Match state, $I[{ }]$ for Insert state and $D[{ }]$ for Delete state. Each element value in DP matrix is dependent on the value of previous element.

Viterbi requires a computationally intensive procedure.

There has been a great deal of work on optimizing HMMER for both CPUs and GPUs. 

JackHMMer \citep{Wun} uses the Intel IXP 2850 network processor to accelerate Viterbi algorithm. The processor is used as a single-chip cluster with the XScale CPU functioning as the head node. Like a typical cluster, the XScale CPU is responsible for distributing jobs to the individual microengines. 

MPI-HMMER \citep{Walters2006} is a wellknown and commonly used MPI implementation. In their studies, a single master node is used to assign multiple database blocks to worker nodes for computing in parallel. And it is responsible for collecting the results.

HMMER3 \citep{HMMER3} is the most significant acceleration of hmmsearch. The main performance gain is due to a heuristic algorithm called MSV filter, for Multiple (local, ungapped) Segment Viterbi, as described in Section\ref{MSVsub}. MSV is implemented in SIMD vector parallelization instructions and is about 100-fold faster than HMMER2.

GPUs have been shown to provide very attractive compute resources in addition to CPUs, because of particular manycore parallel computation in GPUs.

\citep{GPUHMM}, \citep{Ganesan}, \citep{Du} and \citep{Quirem} parallelized Viterbi algorithm on CUDA-enabled GPUs.

[Ahmed et al., 2012]\citep{Ahmed} used Intel VTune Analyzer \citep{Intel} to investigate performance hotspot functions in HMMER3. Based on hotspot analysis, they studied CUDA acceleration for three individual algorithm: Forward, Backward and Viterbi algorithms.

As shown in Figure \ref{fig:hmmsearch}, the MSV and Viterbi algorithms are implemented in the so-called ``acceleration pipeline" at the core of the HMMER3 software package \citep{HMMER3}. And the MSV algorithm is the first filter of ``acceleration pipeline" and is the key hotspot of the whole process. Therefore, this thesis concentrate on porting the MSV onto CUDA-enabled GPU to accelerate hmmsearch application.

\section{Research Contributions}
The contribution of this thesis can be classified as follows:
\begin{itemize}
 \item Analyze the core application \emph{hmmsearch} in HMMER3 and find the key hotspot MSV filter for accelerating hmmsearch.
 \item Implement the protein sequence search tool \emph{cudaHmmsearch} on CUDA-enabled GPU. Demonstrate many optimization approaches to accelerate cudaHmmsearch.
 \item Discuss and analyze the advantages and limitations of GPU hardware for CUDA parallel programming.
\end{itemize}

\section{Organization of thesis}
The rest of this thesis is organized as follows:

Chapter \ref{Background} introduces the background necessary for understanding the work in this thesis.

Then Chapter \ref{CUDAHMMER3} presents the details of our \emph{cudaHmmsearch} implementation and optimization approaches. The six steps are summarized for better performance of CUDA programming at the end of this Chapter.

Comprehensive benchmarks were performed and analyzed in Chapter \ref{Results}. 

The conclusion of Chapter \ref{Conclusions} summarizes our contributions, points out its limitations, and makes suggestions for future work.

\section{Typographical Conventions}
The following font conventions are used in this thesis:
\begin{itemize}
 \item {\fontfamily{phv}\fontseries{m}\selectfont Adobe Helvetica font}\\
 Used for code examples.
 \item {\fontfamily{phv}\fontseries{m}\selectfont \textsl{Adobe Helvetica slanted font}}\\
 Used for comments of code.
 \item {\fontfamily{pag}\selectfont Adobe AvantGarde font}\\
 Used for captions of table and figure.
\end{itemize}
